TCP/IP数据包封装与拆解概述 - echo_bright_的博客 - CSDN博客 https://blog.csdn.net/qq_29344757/article/details/78396507

《Linux高性能服务器编程》阅读笔记：

1. TCP/IP封包流程


  (1) 经过TCP/UDP封装后的数据称为TCP报文段/UDP数据报。因为TCP协议除了会为通信双方维持一个连接，还具有超时重发的功能，所以操作系统会将APP的要发送数据存储在内核的相关数据结构中：



  上图描述的是TCP发送数据时示意图，接收缓冲区也是如此。发送端APP调用系统调用send()/write()函数向TCP连接写数据时，内核中的TCP模块首先将APP数据拷贝到与该连接对应的TCP内核发送缓冲区中，进而将TCP头部信息和TCP发送缓冲区中的数据传递给内核中IP模块，使用IP模块提供的服务。

  对于UDP发送数据，其封装过程与TCP类似，不同的是，因为UDP是提供的是不可靠的服务，所以UDP内核模块不会为APP的数据保存副本，当发送缓冲区的数据被发送出去后，缓冲区的数据就被丢弃。当然，如果APP想实现超时重发，就需要在APP中把数重新拷贝到内核空间的UDP发送缓冲区。另外，由于UDP是基于无连接的通信，所以发送端发送数据时，使用的函数是sendto()指明接收方的地址信息。当然这也不是绝对的，使用bind()函数时例外，详细可读 send()、sendto()和recv()、recvfrom()的使用。

  (2) 接下来的，经过IP封装的数据称为IP数据报，IP数据报中的数据段为UDP数据报/TCP数报文段/ICMP数据报。

  (3) 经过数据链路层封装的数据称为帧。根据传输媒介的不同，帧的类型也不同，例如有以太网帧、令牌环帧。以以太网帧为例，其封装格式为：



  帧数据是最终在物理网络上传输字节序列。需要注意的是帧的最大传输单元(MTU, Max Transmit Unit)，即帧最多能携带多少上层协议的数据(例如IP报文段)会收到网络类型的限制。以太网帧的MTU为1500Byte，过长的IP报文段可能需要被分包传输。

2. TCP/IP拆包流程


  如图，当帧数据到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次根据帧中本层负责的头部信息以获取所需数据，最终将处理后的帧交给目标APP。我理解为，这是一个拆包的过程。

  (1) IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供字段来区分它们。还是以以太网为例，在其帧格式可见，它使用2字节的类型字段来表示上层协议：若为0x800则帧的数据部分为IP数据报，以太网驱动程序会将IP数据报交付给IP模块。若类型字段为0x806则帧的数据部分为ARP的请求/应答报，将会交付给内核的ARP模块。拆包需要依赖于头部信息中的类型字段。

  (2) 同理,ICMP/UDP/TCP都使用IP协议，所以IP数据包的头部采用16位字段来区分。

  (3) TCP/UDP包则通过其头部中的16位端口号来区分上层APP。例如DNS协议占用的端口号为53，HTTP协议占用的端口号为80。

  到达应用层后，APP(或者ARP服务、RARP服务、ICMP服务)将会收到被操作系统封装前的源应用程序数据。所以在APP看来，拆包/封包似乎没有发生过
--------------------- 
作者：echo_bright_ 
来源：CSDN 
原文：https://blog.csdn.net/qq_29344757/article/details/78396507 
版权声明：本文为博主原创文章，转载请附上博文链接！