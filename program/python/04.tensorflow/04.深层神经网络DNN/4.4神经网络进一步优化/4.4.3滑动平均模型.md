
## 1. ExponentialMovingAverage

1. ExponentialMovingAverage
    1. tf.train.ExponentialMovingAverage实现滑动平均模型
    2. 对每一个变量会维护一个影子变量 shadow variable
    3. shadow_variable = decay * shadow_variable + (1 - decay) * variable
    4. 在一定程度提高最终模型在测试数据上的表现

## 2. 代码

```py
import tensorflow as tf

v1 = tf.Variable(0, dtype=tf.float32)
step = tf.Variable(0, trainable=False)
ema = tf.train.ExponentialMovingAverage(decay=0.99, num_updates=step)
# 每一次操作的时候，列表变量[v1]都会被更新
maintain_averages_op = ema.apply([v1]) 

with tf.Session() as sess:
    
    # 初始化
    init_op = tf.global_variables_initializer()
    sess.run(init_op)
    print(sess.run([v1, ema.average(v1)]))  # 输出初始化后变量v1的值和v1的滑动平均值 输出[0.0, 0.0]
    
    # 1. shadow_variable = decay * shadow_variable + (1 - decay) * variable
    # 2. 每次更新完以后，影子变量的值更新
    # 3. 变量的值为指定的值，如果不指定则使用上一次计算的结果

    # 衰减率min{0.99, (1+step)/(10+step)=0.1} = 0.1，
    # varible指定值为5
    # 影子变量为0, 更新为 0.1*0 + 0.9*5 = 4.5
    sess.run(tf.assign(v1, 5))              # 更新v1的值
    sess.run(maintain_averages_op)          # 更新v1的滑动平均值
    print(sess.run([v1, ema.average(v1)]))  # 更新v1的滑动平均值, 输出[5.0, 4.5]
    
    # 衰减率min{0.99, (1+step)/(10+step)=0.999} = 0.99
    # varible指定为10
    # 影子变量为4.5，更新为 0.99*4.5 + 0.01*10 = 4.555
    sess.run(tf.assign(step, 10000))        # 更新迭代轮转数step
    sess.run(tf.assign(v1, 10))
    sess.run(maintain_averages_op)
    print(sess.run([v1, ema.average(v1)]))  # 再次更新滑动平均值, 输出[10.0, 4.5549998]
    
    # varible不指定新值为10
    # 影子变量更新为4.555，更新为 0.99*4.555 + 0.01*10 = 4.60945
    sess.run(maintain_averages_op)
    print(sess.run([v1, ema.average(v1)]))  # 输出[10.0, 4.6094499]
```

## 参考

1. [理解滑动平均(exponential moving average)](https://www.cnblogs.com/wuliytTaotao/p/9479958.html)