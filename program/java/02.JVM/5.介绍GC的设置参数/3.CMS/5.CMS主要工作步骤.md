CMS回收器
CMS（Concurrent Mark Sweep）

* 概述
  * 主要适合场景是对响应时间的重要性需求 大于对吞吐量的要求，
  * 能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用
  * CMS是用于对老年代的回收，目标是尽量减少应用的暂停时间，减少full gc发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代
* CMS收集周期
  * CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停
* CMS的步骤(初始标记和重新标记是独占系统资源的)
  1. 初始标记（STW独占）CMS-initial-mark：从垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记
  2. 并发标记CMS-concurrent-mark：在初始标记的基础上继续向下追溯标记
  3. 预清理CMS-concurrent-preclean：清理前准备以及控制停顿时间
  4. 重新标记（STW独占）CMS-remark：修正并发标记数据；
  5. 并发清理CMS-concurrent-sweep：在标记完成后，正式回收垃圾对象；
  6. 并发重置CMS-concurrent-reset：垃圾回收完成后，重新初始化CMS数据结构和数据；
* 总结
  * 初始标记、并发标记和重新标记都是为了标记出需要回收的对象
  * 并发标记、并发清理和并发重置可以与应用程序线程一起执行
* 预清理
  * -XX:-CMSPrecleaningEnabled，不进行预清理；
  * 预清理是并发的
  * 刻意等待一次新生代GC的发生，根据历史性能数据预测下一次新生代GC可能发生的时间
  * 在当前时间和预测时间的中间时刻，进行重新标记
  * 从最大程度上避免新生代GC和重新标记重合，尽可能减少一次停顿时间
* CMS
  * `并发`是指收集器和应用线程交替执行；
  * `并行`是指应用程序停止，同时由多个线程一起执行GC；
  * CMS（Concurrent Mark Sweep）回收器主要关注与`系统停顿时间`，意为并发标记清除。
  * 基于`标记清除算法`，将会造成内存碎片；
  * `abortable-preclean`，CMS根据之前新生代GC的情况，将`重新标记`的时间放置在一个最不可能和下一次新生代GC重叠的时刻；
  * 当堆内存使用率达到某一阈值时便开始进行回收，以确保应用程序在CMS工作过程中，依然有足够的空间支持应用程序运行；
  * 在CMS执行过程中，已经出现内存不足的情况`concurrent mode failure`，会导致CMS回收失败，虚拟机启动老年代串行收集器进行垃圾回收；

## 参考

1. 实战JAVA虚拟机.JVM故障诊断与性能优化
2. https://www.cnblogs.com/ggjucheng/p/3977612.html
3. https://blog.csdn.net/hqq2023623/article/details/50993165
4. http://www.importnew.com/2782.html