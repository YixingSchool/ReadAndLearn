
# 第 21 章 服务化最佳实践

* 问题
  * 远程调用有性能损耗
  * 网络时延和网络闪断
  * 跨节点的事务一致性问题

## 21.1 性能和时延问题

* 性能损耗
  * 消息序列化，占用CPU计算资源
  * 序列化创建二进制数组，消耗内存
  * 二进制数组，占用网络带宽资源
  * 反射调用服务，性能影响大
* RPC框架高性能设计
  * 影响性能的主要因素
    * IO调度模型：BIO还是NIO
    * 序列化框架的选择：文本协议、二进制协议或压缩二进制协议
    * 线程调度模型：串行调度还是并行调度，锁竞争还是无锁化算法
  * IO调度模型
    * IO多路复用
      * 将多个IO阻塞复用到同一个select的阻塞上
      * 系统在单线程的情况下可以同时处理多个客户端请求
    * JDK1.5_update10的采用epoll代替select/poll提升NIO性能
  * Netty
    * 多路复用器Selector
    * 读写操作是非阻塞的
    * 异步通信模式
  * Netty性能优化
    * 零拷贝
      * 使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝
      * 组合Buffer对象，聚合多个ByteBuffer对象
      * 采用transferTo直接将文件缓冲区的数据发送到目标Channel
    * 内存池
      * 提供基于内存池的缓冲区重构能用机制
    * 无锁化的串行设计
      * 消息的处理尽可能在同一个线程内完成，期间不进行线程切换
      * 同时启动多个串行化的线程并行运行
    * 高效的并发编程
      * volatile
      * CAS和原子类
      * 线程安全容器
      * 读写锁
  * 高性能序列化框架
    * 序列化后的码流大小，占用网络带宽
    * 序列化&反序列化的性能，占用CPU
    * 是否支持跨语言
    * 并发调用的性能表现：稳定性、线性增长、时延毛刺
  * 高性能的Reactor线性模型
    * 专门的NIO线程：Acceptor线程用于监听服务端，接收客户端的TCP连接请求
    * 网络IO操作：读写由一个NIO线程池负责
    * 1个NIO同时处理N条链路，但1个链路只对应1个NIO线程
* 业务最佳实践
  * 异步或并行，提升服务的吞吐量
  * 线程池设置合理，JDK默认最大不超过20
  * 减少传输的码流大小
  * 设置合适的客户端超时时间
  * 重要的服务，可以单独部署到独立的服务线程池中
  * Docker等轻量级OS容器部署服务

## 21.2 事务一致性问题

* 分布式事务设计方案
  * 两阶段提交
    * 全局事务向所有的事务参与制发送准备请求
    * 事务参与者向全局事务管理器回复是否准备就绪
    * 全局事务管理器接收到所有事务参与者的回复
    * 如果事务参与者都可以提交，则向所有事务提交者发送提交申请，否则回滚
  * 两阶段提交采用的是悲观锁策略
    * 性能取决于响应最慢的参与者
    * 整个协议过程需要加锁
    * 当协调者出现故障，整个事务需要协调者恢复后才能继续
  * 最终一致性代替传统的强一致性

## 21.3 研发团队协作问题

* 共用服务注册中心
  * 服务提供者开发方只订阅服务
  * 不注册正在开发的服务
  * 直连测试正在开发的服务
* 直连提供者
* 多团队进度协同
  * 利用依赖管理工具，自动计算出调用链上各个服务的最迟交付时间点
* 服务降级和Mock测试
  * 服务提供者首先将接口定下来并提供给消费者
  * 消费者可以将服务降级同Mock测试结合起来（业务放通）
* 协同调试问题
* 接口前向兼容性
  * 严格执行《服务前向兼容性规范》
  * 接口兼容性技术保障