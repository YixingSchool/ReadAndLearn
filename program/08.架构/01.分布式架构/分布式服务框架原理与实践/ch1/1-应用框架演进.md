

# 第 1 章 应用框架演进

## 1.1 传统垂直应用架构

通过将业务公共能力抽象成原子服务，对复杂应用进行水平拆分和服务化，实现服务消费者和提供者的解耦。

* 架构
  * LAMP
  * MVC
  * EJB

### 1.1.1 垂直应用架构介绍

* MVC
  * 展示层（View）：展示业务数据，接收用户输入，不执行业务逻辑，不改变数据模型
  * 控制层（Control）：请求的分发，调度后台业务执行，调用视图返回数据
  * 模型层（Model）：业务数据和业务执行逻辑
  * 标准的MVC不包含数据访问层：屏蔽了底层的数据连接池和数据源实现
* 补救
  * 热双机
  * 服务端监听浮动IP
  * Watch Dog检测应用进程
  * F5或SLB等负载均衡

### 1.1.2 垂直应用架构面临的挑战

* 弊端
  * 应用开发成本高，部署效率低
  * 团队协作效率差，代码重复率高
  * 系统可靠性差
  * 维护和定制困难
  * 新功能上线周期变长
    * 公共API变更导致测试工作量激增
    * 新特性无法独立部署和交付

## 1.2 RPC架构

* RPC（Remote Procedure Call）：允许像调用本地服务一样调用远程服务
  * Spring HTTP Invoker
  * Facebook Thrift
* 优点
  * 简单
  * 高效
  * 通用

### 1.2.1 RPC框架原理

* RPC功能
  * 屏蔽底层的传输方式（TCP或UDP）
  * 序列化方式（XML/JSON/二进制）
  * 通信细节
* 技术点
  * 远程服务提供者需要以某种形式提供服务调用相关的信息
  * 远程代理对象：服务调用者调用的服务实际是远程服务的本地代理
  * 通信：RPC框架与具体的协议无关。例如：Spring提供HTTP Invoke, RMI Invoke, MessagePack私有的二进制压缩协议
  * 序列化：将对象转换成二进制码流进行网络传输

### 1.2.2 最简单的RPC框架实现

不依赖第三方类库，实现最简单RPC框架

* Java原生技术
  * 序列化
  * Socket通信
  * 动态代理
  * 反射机制
* RPC框架组成
  * 服务提供者：提供服务接口定义和服务实现
  * 服务发布者：负责将本地服务发布成远程服务
  * 本地服务代理：通过代理调用远程服务提供者，将结果封装返回给本地消费者
* 代码
  * Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())
  * executor.execute(new ExporterTask(server.accept()))
  * ObjectInputStream, ObjectOutputStream, Method.invoke
* 服务端 主要职责
  * 服务端，监听客户端的TCP连接
  * 将客户端发送的码流反序列化成对象，反射调用服务实现者，获取执行结果
  * 将执行结果对象反序列化，通过Socket发送给客户端
  * 远程服务调用完成后，释放Socket等连接资源
* 本地代理 主要功能
  * 将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用
  * 创建Socket客户端，根据指定地址连接远程服务提供者
  * 将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务调用者
* 测试代码
  * 创建一个异步发布服务端的线程并启动，用于接收RPC客户端请求
  * 创建客户端服务代理类，构造RPC请求参数，发起RPC调用

### 1.2.3 业界主流RPC框架

* 主流RPC框架
  * Facebook Apache Thrift
  * Hadoop Avro-RPC
  * caucho Hessian
  * Google gRPC
* Apache Thrift
  * 多语言远程服务调用框架
  * 采用接口描述语言（IDL）定义并创建服务
  * 可扩展的跨语言服务
  * 代码生成引擎
  * 采用二进制传输数据
  * 提供阻塞、非阻塞、单线程和多线程的模式
  * 通信协议
    * 二进制：省带宽，传输效率高
    * 文本：可读性高
    * 常用协议
      * TBinaryProtoco: 二进制编码格式数据传输协议
      * TCompactProtocl: 高效率的压缩二进制编码格式数据传输协议
      * TJSONProtocol: 使用JSON编码的数据传输协议
  * 通信方式
    * TSocket: 阻塞式I/O
    * TFramedTransport: 非阻塞，按块进行传输，类似于Java中NIO非阻塞通信
    * TNonblockingTransport: 非阻塞
* Apache Avro
  * 丰富数据结构类型
  * 快速可压缩的二进制数据形式
  * 存储持久数据的文件容器
  * 简单的动态语言结合功能
  * 特点
    * 支持动态模式：Avro不需要生成代码
    * 数据无须加标签
    * 无须手工分配的域标识
  * 优点，可定制性高
    * 传输层和业务逻辑层分离
    * 服务端有协议注册工厂和序列化注册工厂，可定制私有协议和不同序列化方式
    * 客户端支持同步和异步调用
* Hessian
  * 通过Servlet提供远程服务
  * Spring的DispatcherServlet将匹配模式的请求转发到Hessian服务
  * 使用动态代理来实现Hessian的远程过程调用
* gRPC
  * 基于HTTP/2协议标准而设计
  * 基于ProtoBuf序列化协议开发
  * 双向流、流控、头部压缩、单TCP连接复用
  * 特性
    * 支持Protobuf
      * 使用ProtoBuf的IDL（.proto）来定义数据结构和服务
      * 通过代码生成工具可以自动生成不同语言版本的源代码
      * 数据结构向前兼容
      * 支持多语言

### 1.2.4 RPC框架面临的挑战

* 挑战
  * 服务URL配置管理变得困难：需要服务注册中心，动态注册和发现服务
  * 负载均衡器的单点压力越来越大：消费者在本地缓存服务提供者列表，实现软负载均衡
  * 需要分布式消息跟踪系统可视化展示服务调用链，用于依赖分析、业务调用路径梳理
  * 容量规划问题：采集服务调用KPI数据，进行汇总和分析，通过计算得出服务部署实例数和服务器的配置规格
  * 服务声明周期管理流程
  * 服务治理

## 1.3 SOA服务化架构

SOA是一种粗粒度、松耦合的以服务为中心的架构，接口之间通过定义明确的协议和接口进行通信

Service Oriented Architecture面向服务的架构

### 1.3.1 面向服务设计的原则

* SOA面向服务的原则
  * 服务可服用
  * 服务共享一个标准契约
  * 服务松耦合
  * 服务是底层逻辑的抽象
  * 服务是可组合、可编排的
  * 服务是自治的
  * 服务是无状态的
  * 服务是可被自动发现的

### 1.3.2 服务治理

* 挑战
  * 分布式框架下的服务调用性能
  * 服务化框架如何支持线性扩展
  * 如何实现高效、实时的服务多维度监控
  * 大规模分布式环境下的故障快速定界和定位
  * 分布式环境下海量日志在线检索、模糊查询
  * 服务的流控、超时控制、服务升降机等管控手段
  * 服务的划分原则
* SOA服务治理
  * 服务定义：对服务进行标识，描述其功能
  * 服务生命周期管理
    * 计划阶段：标识新服务
    * 测试阶段：上线前对服务进行测试
    * 运行阶段：
    * 弃用阶段：服务仍在运行，但不会长时间运行
    * 废弃阶段：生命周期结束
  * 服务版本治理
    * 问题修复
    * 新增功能
    * 删除非必须功能
    * 向前兼容
  * 服务注册中心：支持服务的订阅发布和动态发现机制
  * 服务监控：调用时延、成功率、吞吐率
  * 运行期服务质量保障，在不重启服务的前提下达到快速提升服务运行质量
    * 服务限流
    * 服务迁入迁出
    * 服务升降级
    * 服务权重调整
    * 服务超时控制
  * 快速的故障定界定位手段
    * 日志分析系统
    * 分布式消息跟踪系统
  * 服务安全
    * 通过动态生成令牌（Token）的方式做安全访问授权

## 1.4 微服务架构

微服务架构MSA

### 1.4.1 什么是微服务

* 大多数异构系统并没有使用统一的服务化框架进行深入改造
  * 通过将业务接口发布成标准的Web服务（SOAP）
  * 通过企业服务总线（ESB）进行异构协议的转换
  * Data Mapper和消息路由实现与其他服务互通
* 产生微服务的原因
  * 敏捷开发强调迭代开发，快速交付可用的功能
  * 持续交付促使构建更快、更可靠、更频繁的软件部署和交付能力
  * CI自动化构建简化环境的创建、编译、大包和部署
  * DevOps促使小团队独立运作和交付
* 微服务特征
  * 原子服务：单一职责原则
  * 高密度部署
  * 敏捷交付
  * 微自治

### 1.4.2 微服务架构对比SOA

* 差异
  * 服务拆分粒度小：SOA解决异构应用的服务化；微服务强调的是服务拆分尽可能小
  * 服务依赖：SOA大量的服务间依赖；微服务的设计理念是服务自治，避免依赖其他服务
  * 服务规模：SOA多服务合并打包；微服务独立性高
  * 架构差异：企业集成总线ESB（实总线）被P2P的虚拟总线代替
  * 服务治理：静态治理转型为服务运行态微治理
  * 敏捷交付：