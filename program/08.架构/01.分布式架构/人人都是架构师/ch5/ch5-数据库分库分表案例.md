

# 第5章 数据库分库分表案例

## 5.1 关系型数据库的架构演变

* 性能瓶颈
  * 单库难以承受的并发读写操作
  * 单表存储数据量过程，检索效率低

### 5.1.1 数据库读写分离

* 读写分离
  * Master负责写操作
  * Slave负责读操作
  * Master与Slave数据库之间数据库同步是会存在一定延迟

### 5.1.2 数据库垂直分库

* 垂直分库
  * 将原本冗余在单库中的数据库拆分到不同的业务库中
  * 实现分而治之的数据管理和读写操作
  * 当MySQL单表数据超过500万行，读操作逐渐成为瓶颈
  * 写是顺序写，不会因为数据膨胀而成为瓶颈
  * 读操作一定会存在上限

### 5.1.4 MySQL Sharding与MySQL Cluster的区别

* MySQL CLuster
  * 数据库集群，扩展了数据库的并行处理能力
* MySQL Sharding
  * 提升并行处理能力
  * 解决单表数据量过大所产生的检索瓶颈


## 5.2 Sharding中间件

* 问题
  * 定义Shard Key路由条件，路由维度直接决定数据的罗盘位置
  * 根据定义的Shard Key进行数据库路由

### 5.2.1 常见的 Sharding中间件对比

* 类型 
  * Proxy架构：实现任意的关系型数据库协议
  * 应用集成架构：直连数据库，读写性能高

### 5.2.2 Shark简介

* 优点
  * 动态数据源
  * 分布式路由算法支持
  * 非Proxy架构，直连数据库，降低外围系统依赖
  * 业务零侵入
  * 基于Spring JDBC、Druid Sqlparser完成SQL解析
  * 支持多机SequenceID API
  * 支持ZooKeeper，Redis3.x Cluster集中式资源配置中心
  * 基于Velocity模板引擎渲染，支持SQL语句独立配置和动态拼接
  * 提供内置SQL验证页面
  * 提供自动生成配置文件

### 5.2.3 Shark的架构模型

* 数据路由
  * 以Shard Key为条件
  * 按照特定的路由算法和规则对多数据源进行动态切换，**定位**到目标业务库
  * 将SQL语句中的全局表名进行解析和重写替换
* SharkDataSourceGroup
  * 派生自AbstractRoutingDataSource类
  * 通过Spring AOP方式在运行时采用Druid的Sqlparser完成对SQL语句的解析工作
* 架构
  * 动态数据源层
  * 读写分离层
  * 分库分表层

### 5.2.4 使用Shark实现分库分表后的数据路由任务

* 模式
  * 单库多表模式
  * 多库多表模式
* 单库多表
  * 垂直分库：单库中的数据表拆分到不同的业务库中，实现分而治之的数据管理和读写操作
  * 水平分表：单个业务表拆分为n个“逻辑相关”的业务子表
* 多库多表配置
  * isShard定义分库分表的开关
  * wr_index数据库主从读写分离的起始索引，r32w0
    * 指定Master的数据源索引范围在0到31之间
    * 指定Slave的数据源索引范围在31到63之间
  * sharedMode设置为true，采用多库多表模式，反之采用单库多表模式
  * consistent只应用与多库多表模式下，设置为true时，表名后缀是连续的
  * 对单库进行水平分库时，遵循“二叉树分库”
  * 基于Spring的AOP拦截JdbcTemplate中除去batch()方法外的所有读写方法

### 5.2.5 分库分表后所带来的影响

* 问题
  * ACID：Atomicity原子性、Consistency一致性、Isolation隔离性、Durability持久性
  * 多表之间的关联查询
  * 无法使用外键约束
  * 无法生成全局唯一和连续ID
* 单表查询
  * 多次单表查询在执行效率上并不比多表联合查询慢多少  
  * 单表查询查询语句简单，易于理解、维护和扩展
  * 缓存利用率高

### 5.2.6 多机SequenceID解决方案

* 多机SequenceID
  * 唯一性、连续性
  * 唯一ID：利用UUID、物理机IP、随机值、时间戳
  * Shark提供生成SequenceID的API，底层支持数据库和ZooKeeper作为申请SequenceID的存储系统
  * Shark每次从数据库中取出一段ID，然后缓存本地
  * 一旦ID生成器取了一段ID，系统突然宕机，这一组ID将会废弃
* getSequenceId()
  * idcNum：区分不同的IDC机房
  * type：业务类别
  * memData：想数据库申请的ID缓存数  

### 5.2.7 使用Solr满足多维度的复杂条件查询

* Solr
  * like模糊查询
  * 多维度的复杂查询

### 5.2.8 关于分布式事务

* 分布式系统的一致性协议
  * 两阶段提交协议
  * 三阶段提交协议
  * Paxos协议
* 实施
  * 分布式事务的实施与业务本身的耦合度非常高
  * 并发要求高的系统，分布式事务是最主要的性能瓶颈

## 5.3 数据库的HA方案

### 5.3.1 基于配置中心实现主从切换

* ZooKeeper配置中心
  * 打开Slave读写权限
  * 修改Share主从起始索引的属性“wr_index”
  * 确保Spring bean标签“destory-method”一定要设置“close”，Share要销毁连接池所占用的数据库连接

### 5.3.2 基于Keepalived实现主从切换

* Keepalived
  * Master和Slave上的Keepalived程序会互相发送心跳，确认是否存活
  * Master上的数据库状态发生异常，Master上Keepalived停止运行，Slave上的Keepalived接管VIP
  * notify_down指定数据库宕机后需执行的脚本，如将Slave库的读写权限打开
  * 主从切换过程的数据不丢失：将数据插入消息队列，通过failover机制尝试多次

### 5.3.3 保障主从切换过程中的数据一致性

* 主从同步
  * 写入Master之前也将同一份数据落到缓存中
  * 非高峰期，开启半同步复制
    * 当事务提交到Master，Master等待Slave收到Binlog后，才响应请求已经完成。
  * MySQL5.6之后开始提供GTID（全局事务ID），保证主从之间数据的最终一致性

## 5.4 订单业务冗余表需求

* 订单表冗余
  * 卖家订单表
  * 买家订单表

### 5.4.1 冗余表的实现方案

* 数据写入
  * 数据同步写入：按照先后顺序，写完第一张表后再写另外一张表
  * 数据异步写入：写完第一张后，异步写入到第二张表
* 数据双写一致性
  * 优先写入t_order_buyer，用户可以继续推动订单状态的流转
  * 反之如果用户看不到系统新生成的订单，那对商家而言是没有意义

### 5.4.2 保障冗余表的数据一致性

* 冗余表的数据一致性
  * 分布式事务具有复杂性和低效性
  * 采用最终一致性方案
* 线上检测补偿
  * 写入t_order_buyer，立即将消息写入到消息队列
  * 写入t_order_seller，立即将消息写入到消息队列
  * 消费者消费到第1条消息后，在指定时间范围内没有消费到第2条，则需执行数据补偿
* 线下检测补偿
  * 写入t_order_buyer，立即将数据写入到log1
  * 写入t_order_seller，立即将数据写入到log2
  * 指定Job不听增量对比log1和log2，如数据不一致，则进行数据补偿

  

