
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [7 分析Java堆](#7-分析java堆)
	* [7.1 内存溢出的原因](#71-内存溢出的原因)
* [7.2 String在虚拟机中的实现](#72-string在虚拟机中的实现)
	* [7.3 使用MAT分析Java堆](#73-使用mat分析java堆)
	* [7.4 筛选堆对象：MAT对OQL的支持](#74-筛选堆对象mat对oql的支持)

<!-- /code_chunk_output -->
---

# 7 分析Java堆

内存溢出 VS 内存泄露

## 7.1 内存溢出的原因

* 堆溢出
  * 大量持有强引用的对象占据了堆空间，导致无法回收。
  * -Xmx参数指定更大的堆空间；
  * 分析找到大量占用堆空间的对象；
* 直接内存溢出
  * 堆外的内存空间，直接向操作系统申请；
  * 直接内存的申请速度一般要比堆内存慢，但是其访问速度要快于堆内存；
  * 显式GC可以回收直接内存；
  * 设置-XX:MaxDirectMemorySize：最大可用直接内存，默认等于-Xmx的值；
* 栈溢出
  * 栈空间在堆外分配；
  * 减少堆空间，操作系统预留更多内存用于线程创建；
  * 减少线程的内存空间，-Xss；
* 永久区溢出
  * 一个系统不断的产生新的类，而没有回收；
  * 增加MaxPermSize的值；
  * 减少系统需要的类的数量；
  * ClassLoader装载类，定期回收；
* GC效率低

# 7.2 String在虚拟机中的实现

* 特点
  * 不变性
  * 针对常量池的优化
  * 类的final定义
* 不变性
  * 一旦生成对象，不能再改变；
  * 对象被多线程共享，访问频繁时，省略同步和锁等待的时间；
  * 修改的操作依靠产生新的字符串实现；
* 常量池
  * 两个String对象相同值，只引用常量池中同一个拷贝；
  * String.intern()返回字符串在常量池中的引用。如果常量池中没有，会将字符串加入常量池；
  * 在一次intern()调用后，字符串被回收，再进行一次intern()调用，字面量相同的字符串重新加入常量池，但**引用位置不同**；
* final
  * final变量在编译后会直接替换成对应的值
* 内存泄露
  * 由于疏忽或错误造成程序**未能释放已经不再使用的内存**的情况；
  * JDK1.6，String.substring()。新生成的String使用相同的value，只修改offset和count，节省内存，字符串回收时多余部分造成空间浪费；
  * JDK1.7，不再复用原String的value，只复制实际部分；

## 7.3 使用MAT分析Java堆

* 功能
  * 查看Java层面的应用线程，无法查看虚拟机的系统线程；
  * **入引用incoming**：引用当前对象；
  * **出引用outgoing**：当前对象引用的对象；
  * **浅堆Shallow Heap**：对象本身所占用的内存，不包括内部引用对象的大小；
  * **深堆Retained Heap**：只能通过该对象直接或间接访问到的所有对象的浅堆之和(**保留集Retained Set**)，对象被GC回收后可以释放的内存；
* 支配树
  * 所有指向对象B的路径都经过对象A，则A**支配**B；
  * 对象A是离对象B最近的支配对象，则称A为B的**直接支配者**；

## 7.4 筛选堆对象：MAT对OQL的支持

* select
  * OBJECTS返回对象实例信息
  * AS RETAINED SET获得保留集
  * DISTINCT去重
* from
  * 指定类名、正则表达式或对象地址
  * INSTANCEOF返回指定类所有子类实例
  * OBJECTS返回类信息
* where
  * like 正则
  * !=null
* 访问
  * 堆内对象的属性：alias. field.field.field
  * 堆内代理对象的属性：alias. @attribute
  