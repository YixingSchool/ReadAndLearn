
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [第12章　java内存模型与线程](#第12章-java内存模型与线程)
* [12.3　java内存模型](#123-java内存模型)
	* [12.3.5　原子性、可见性与有序性](#1235-原子性-可见性与有序性)
		* [深入理解Java虚拟机笔记---原子性、可见性、有序性](#深入理解java虚拟机笔记-原子性-可见性-有序性)
			* [1.原子性(Atomicity)](#1原子性atomicity)
			* [2.可见性(Visibility)](#2可见性visibility)
		* [Java可见性机制的原理](#java可见性机制的原理)
			* [基本概念](#基本概念)
			* [Volatile](#volatile)
			* [final](#final)
			* [Happens-Before规则](#happens-before规则)

<!-- /code_chunk_output -->



# 第12章　java内存模型与线程 


# 12.3　java内存模型 

## 12.3.5　原子性、可见性与有序性 

### 深入理解Java虚拟机笔记---原子性、可见性、有序性

* [深入理解Java虚拟机笔记---原子性、可见性、有序性 - xtayfjpk的专栏 - CSDN博客 ](http://blog.csdn.net/xtayfjpk/article/details/41969915)


Java内存模型是围绕着并发过程中如何处理原子性、可见性、有序性这三个特征来建立的，下面是这三个特性的实现原理：

#### 1.原子性(Atomicity)

由Java内存模型来直接保证的原子性变量操作包括**read、load、use、assign、store和write**六个，大致可以认为基础数据类型的访问和读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了**lock和unlock**操作来满足这种需求，尽管虚拟机未把lock与unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐匿地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块---synchronized关键字，因此在synchronized块之间的操作也具备原子性。

#### 2.可见性(Visibility)
   
可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。

除了volatile之外，Java还有两个关键字能实现可见性，它们是**synchronized**。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的，而**final关键字的可见性**是指：被final修饰的字段是构造器一旦初始化完成，并且构造器没有把“this”引用传递出去，那么在其它线程中就能看见final字段的值。

3.有序性(Ordering)
   Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。
   Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则来获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

先行发生原则：
   如果Java内存模型中所有的有序性都只靠volatile和synchronized来完成，那么有一些操作将会变得很啰嗦，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”(Happen-Before)的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的主要依赖。
   先行发生原则是指Java内存模型中定义的两项操作之间的依序关系，如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。它意味着什么呢？如下例：

```java

//线程A中执行  
i = 1;  
  
//线程B中执行  
j = i;  
  
//线程C中执行  
i = 2;  
```

  假设线程A中的操作”i=1“先行发生于线程B的操作”j=i“，那么我们就可以确定在线程B的操作执行后，变量j的值一定是等于1，结出这个结论的依据有两个，一是根据先行发生原则，”i=1“的结果可以被观察到；二是线程C登场之前，线程A操作结束之后没有其它线程会修改变量i的值。现在再来考虑线程C，我们依然保持线程A和B之间的先行发生关系，而线程C出现在线程A和B操作之间，但是C与B没有先行发生关系，那么j的值可能是1，也可能是2，因为线程C对应变量i的影响可能会被线程B观察到，也可能观察不到，这时线程B就存在读取到过期数据的风险，不具备多线程的安全性。
   下面是Java内存模型下一些”天然的“先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。
a.程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。
b.管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。
c.volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。
d.线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。
e.线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。
f.线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。
g.对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。
g.传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

  一个操作”时间上的先发生“不代表这个操作会是”先行发生“，那如果一个操作”先行发生“是否就能推导出这个操作必定是”时间上的先发生“呢？也是不成立的，一个典型的例子就是指令重排序。所以时间上的先后顺序与先生发生原则之间基本没有什么关系，所以衡量并发安全问题一切必须以先行发生原则为准。

### Java可见性机制的原理

* [Java可见性机制的原理 - HuMingChuan - 博客园 ](http://www.cnblogs.com/humc/p/5426351.html)


#### 基本概念
* 可见性：当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。
* 内存屏障（Memory Barriers）：处理器的一组指令，用于实现对内存操作的顺序限制。
* 缓冲行：CPU告诉缓存中可以分配的最小存储单位，处理器填写缓存行时，会加载整个缓存行。
* Lock前缀的指令：Lock前缀的指令在多核处理器下会发生两件事情：
1）将当前处理器的缓存行的数据协会到系统内存。
2）这个写回内存的操作会使其他CPU缓存了该内存的地址的数据无效。
* 缓存一致性协议：在多处理器下，为零保证各个处理器的缓存是一致的，每个处理器都会通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了。当处理器发现自己缓存行对应的地址被修改，就会将当前处理器的缓存行设置为无效状态。当处理器对这个数据进行读写的时候，会重新把数据从内存中读取到处理器缓存中。

* CAS：CompareAndSwap 比较并交换。CAS操作需要输入两个值，一个旧值（执行CAS操作前的值，期望值）和一个新值，只有当当前值等于旧值时，才可以将当前值设置为新值，否则不设置。这是一个原子操作，由硬件保证。

* 重排序规则：从根本上来所，JMM 对编译器和处理器的重排序限制只有一条，只要不改变程序执行的结果（指的是单线程或者正确同步的多线程环境下），那么编译器和处理器怎么优化都可以。

#### Volatile
从上面的Lock前缀指令和缓存一致性协议可以看出来，这就是volatile的实现原理了。
实际上，valatile变量被写入时，确实加了一个Lock前缀的指定，以此来达到可见性的目的。

#### final
Final域只能被显示地赋值一次，但是这并不代表final域不能被多次初始化。
比如：final int i ;i在构造函数中被赋值之前，就会被初始化为默认的值：0.通过调试代码可以证明这一点。

为了保证final域的值不会在为初始化的情况下被访问到，程序员只需要保证一点即可：即，在构造函数中，正在被构造的对象（this）没有“逸出”，那么不需要任何同步手段，就能保证任意线程看到的final域，包括基本类型和引用类型，都是已经被正确地通过构造函数初始化过了的。

一个会是正在被构造的对象逸出的例子：

```java
public class FinalTest{
   final int i;
   static FinalTest obj;

   public FinalTest(){
   i  =1;
   /**
   *这里会使正在被构造的对象逸出，如果和上一句做了重排序，那么其他线程就可以通过obj访问到还为被初始化的final域。
   **/
   obj = this; 
  }
}
```

#### Happens-Before规则
happens-before的含义

Happen-Before规则用来描述两个操作之间的顺序关系，这两个操作可以再一个线程内，也可以不再一个线程内。此顺序并不严格意味着执行时间上的顺序，而是至前一个操作的结果要对后一个操作可见。

Happens-Before关系的定义如下：

如果一个happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。
举例来说，如果在程序执行顺序上，A先于B，并且A修改了共享变量，而B正好使用该共享变量，那么A需要happen-before B，再直白一点，就是A对共享变量的修改，需要在B执行时，对B可见。

happens-before规则

程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
volatile规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
传递性：如果Ahappens-before B，并且B happens-before C，那么A happens-before C。
start()规则：如果线程A执行操作ThreadB.start()，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
对所有这些规则的说明：Ahappens-before B并不意味着A一定要先在B之前发生，而是说，如果A已经发生在了B前面，那么A的操作结果一定要对B可见

分类: Java多线程,JDK源码学习
标签: JDK, 多线程, 并发, 原理, 重排序, happens-before