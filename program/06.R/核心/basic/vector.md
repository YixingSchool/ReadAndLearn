

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [R语言学习笔记：向量](#r语言学习笔记向量)
	* [向量是R语言最基本的数据类型。](#向量是r语言最基本的数据类型)
	* [冒号运算符](#冒号运算符)
	* [循环补齐recycle](#循环补齐recycle)
	* [取模运算%%](#取模运算)
	* [向量索引](#向量索引)
	* [seq()创建向量](#seq创建向量)
	* [rep重复向量常数](#rep重复向量常数)
	* [all()和any()](#all和any)
	* [向量化](#向量化)
	* [NA与NULL](#na与null)
	* [筛选filtering](#筛选filtering)
	* [向量化的ifelse()](#向量化的ifelse)
	* [判断向量是否相等](#判断向量是否相等)
	* [给向量元素命名names()](#给向量元素命名names)
* [R语言中向量的加法和乘法](#r语言中向量的加法和乘法)
	* [1，相同长度的向量相加](#1相同长度的向量相加)
	* [2，不同长度的向量相加](#2不同长度的向量相加)

<!-- /code_chunk_output -->


# R语言学习笔记：向量

* [R语言学习笔记：向量 - 申龙斌的程序人生 - 博客园 ](http://www.cnblogs.com/speeding/p/3537947.html)

R语言学习笔记：向量

## 向量是R语言最基本的数据类型。

单个数值(标量)其实没有单独的数据类型，它只不过是只有一个元素的向量。

```r
x <- c(1, 2, 4, 9)

x <- c(x[1:3], 88, x[4])   #在最后一个数前面插入一个数值88，可以看到用x[4]可以取出第4个元素，用x[1:3]可以取出前3个元素

typeof(x)    #查看向量里的元素的类型，注意默认是double。[1] "double"

mode(x)    #r语言中变量类型称为模式(mode)。[1] "numeric"

length(x)  #获取向量的长度
```
 

R不需要提前申明变量，大小写敏感，数组是从1开始。

## 冒号运算符
```r
1:4     #R是一种函数式语言，冒号也是一种运算符（实际上这是一种中置运算符的表示法），可以产生序列。[1] 1 2 3 4

":"(1, 4)    #与1:4是等价的，用引号引起来，就是一种函数名了，不过这种写法看上去比1:4怪异多了

5:1 #结果：[1] 5 4 3 2 1

1:10 - 1 #冒号的优先级比加减运算要高，实际上就是(1:10) - 1，结果： [1] 0 1 2 3 4 5 6 7 8 9 
1:(10-1) #结果：[1] 1 2 3 4 5 6 7 8 9
```

## 循环补齐recycle
这种特性在其它语言中以前还没有看见过！超强的向量运算功能！

```r
y <- c(1,2,3) + 4     # 单个的数值4会被补齐为c(4,4,4)，最后结果为c(5,6,7)
c(1,2,3) * c(4,5,6)   # 结果：[1]  4 10 18，这里表示的两个向量中的元素分别相乘，如果想求向量的点积(dot prod)，就需要用这个%*%函数了
c(1,2,3) %*% c(4,5,6)  #结果是一个1x1的矩阵，其中只有一个元素14
c(1,2,3) * c(4,5,6,7) #结果：[1]  4 10 18  7。同时给出警告信息：长的对象长度不是短的对象长度的整倍数
```

## 取模运算%%
```r
c(7,8,9) %% 3  #结果：[1] 1 2 0
```

## 向量索引
普通的语言中索引只能是正整数，但这里的索引可以是向量，还可以是负数。严格说来这不能叫索引，而是筛选操作，看后面的filtering

```r
x <- c(1,3,5,7,9)
x[2] #结果：[1] 3
x[c(5,4,3,2,1)]   #结果为：[1] 9 7 5 3 1
x[sample(1:5)]  #把1,3,5,7,9乱序排列，每次运行你会得到一个不同的结果
x[-1] #[1] 3 5 7 9，把第一个元素除掉，这是我非常喜欢的语法特性！
x[1:3] #结果：[1] 1 3 5
```

## seq()创建向量

```r
seq(from=12, to=30, by=3)    # 也可以写成： seq(12,30,3) 
[1] 12 15 18 21 24 27 30
seq(from=1.1, to=2, length=10) 
[1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0
x <- c(1,2,4,8) 
seq(x) 
[1] 1 2 3 4
seq(1,5)与1:5是一个意思
```

## rep重复向量常数

```r
rep(8, 4) 
[1] 8 8 8 8

rep(1:3, 2) 
[1] 1 2 3 1 2 3

rep(1:3, each=2) 
[1] 1 1 2 2 3 3
```

## all()和any()

```r
x<-(1:10) 
any(x>8) #只要向量中有一个大于8，就返回真 
[1] TRUE 
all(x>8) #所有都大于8，才返回真 
[1] FALSE
```

## 向量化

```r
w <- function(x) return (x+1)   #加号运算符支持向量，所以自定义的函数w也是向量化的！看上去简单的x+1，但我们已经写出了一个向量函数

w(1) #这是我们最熟悉的函数调用 
[1] 2

w(c(1,3,5)) #可以对向量进行运算 
[1] 2 4 6
```

## NA与NULL
在统计过程中，经常会遇到缺失值，称为NA，即Not Available。

R语言中许多函数可以忽略NA值。

```r
> x <- c(1,2,NA,4) 
> mean(x)  #有缺失值，无法计算平均值 
[1] NA

> mean(x, na.rm=TRUE) #忽略NA值 
[1] 2.333333

> mean(c(1,2,NULL,4))   # NULL值会自动略过 
[1] 2.333333

> length(c(1,2,NA,4))    #统计个数时NA被计算在内 
[1] 4

> length(c(1,2,NULL,4)) 
[1] 3
```

## 筛选filtering
有点像索引，因为也是放在[]里，可以把满足一定条件的元素取出来。

```r
> z <- 1:10 
> z 
[1]  1  2  3  4  5  6  7  8  9 10

> z[z%%2==0] 
[1]  2  4  6  8 10

> z%%2    #取模 
[1] 1 0 1 0 1 0 1 0 1 0

> z%%2==0    #注意这里的0被自动循环补齐 
[1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE

> x<-c(1,3,5,6,9) 
> x[x>3] <- 0   #把大于3的数值都置为0 
> x 
[1] 1 3 0 0 0

subset也是筛选，区别在于处理NA的方式上 
> x<-c(1,2,NA,4,5) 
> x[x>3] 
[1] NA  4  5 
> subset(x, x>3)    #自动把NA剔除掉了 
[1] 4 5

which()可以找到满足条件的元素的位置 
> x <- c(5,  2,  -3, 9, 1) 
> x[x*x>8] 
[1]  5 -3  9 
> which(x*x>8) 
[1] 1 3 4
```

## 向量化的ifelse()
> x <- c(5, 2, -3, 9, 1) 
> ifelse(x>3, 2*x, 3*x) 
[1] 10  6 -9 18  3

## 判断向量是否相等
> x <- 1:3 
> y <- c(1,3,4) 
> all(x==y) 
[1] FALSE 
> identical(x,y) 
[1] FALSE

注意1:3是整数，c(1,2,3)是浮点数，它们不相等： 
> identical(1:3, c(1,2,3)) 
[1] FALSE 
> typeof(1:3) 
[1] "integer" 
> typeof(c(1,2,3)) 
[1] "double"

## 给向量元素命名names()
> workdays <- 1:5 
> names(workdays) <- c("mon", "tue", "wed", "thu", "fri") 
> workdays 
mon tue wed thu fri 
  1   2   3   4   5

可以用名称来引用元素 
> workdays["wed"] 
wed 
  3

# R语言中向量的加法和乘法

* [R语言中向量的加法和乘法 - 我愛红金龙的专栏 - CSDN博客 ](http://blog.csdn.net/hongjinlongno1/article/details/52263403)

在R语言中，不同长度的向量也是可以相加和相乘的，乘法的规则和加法类似
## 1，相同长度的向量相加
```r
> x<- 1:4  
> y<- 1:4  
> z<- x+y  
> z  

[1] 2 4 6 8  
```

规则就是 x[1]+y[1]，x[2]+y[2]，x[3]+y[3]，x[4]+y[4]
```r
> x<- 1:4  
> y<- 1:4  
> z<- x*y  
> z  
[1]  1  4  9 16  
```

乘法也类似

## 2，不同长度的向量相加
```r
> x<- 1:4  
> y<- 1:3  
> z<-x+y  
警告信息：  
In x + y : 长的对象长度不是短的对象长度的整倍数  
> z  
[1] 2 4 6 5  
>   
注意R返回了一个警告消息而不是一个错误消息， 因此这个操作实际上是
被执行了的。 
```

这一类的规则就是 x[1]+y[1]，x[2]+y[2]，x[3]+y[3]，x[4]+y[1](因为y[3]就结束了，进入了又一次循环)

乘法规则类似
```r
> x<- 1:4  
> y<- 1:3  
> z<- x*y  
警告信息：  
In x * y : 长的对象长度不是短的对象长度的整倍数  
> z  
[1] 1 4 9 4  

另外，所得的向量长度为最长的那个向量的长度
```r
> x<- 1:4  
> y<- 1:3  
> z<- 2:3  
> w<- x+y+z  
警告信息：  
In x + y : 长的对象长度不是短的对象长度的整倍数  
> w  
[1] 4 7 8 8  
> v<-x*y*z  
警告信息：  
In x * y : 长的对象长度不是短的对象长度的整倍数  
> v  
[1]  2 12 18 12  
>
```

但是这里出了一个问题，
```r
> x<- 1:4  
> y<- 1:3  
> z<- 2:3  
> x+y+z  
[1] 4 7 8 8  
警告信息：  
In x + y : 长的对象长度不是短的对象长度的整倍数  
> x+z+y  
[1] 4 7 8 8  
警告信息：  
In x + z + y : 长的对象长度不是短的对象长度的整倍数  
> z+x+y  
[1] 4 7 8 8  
警告信息：  
In z + x + y : 长的对象长度不是短的对象长度的整倍数  
><span style="color:#ff0000;"> z+y+x  
[1] 4 7 8 7</span>  
警告信息：  
1: In z + y : 长的对象长度不是短的对象长度的整倍数  
2: In z + y + x : 长的对象长度不是短的对象长度的整倍数  
> z*x*y  
[1]  2 12 18 12  
警告信息：  
In z * x * y : 长的对象长度不是短的对象长度的整倍数  
> z*y*x  
[1]  2 12 18  8  
警告信息：  
1: In z * y : 长的对象长度不是短的对象长度的整倍数  
2: In z * y * x : 长的对象长度不是短的对象长度的整倍数  
>
```


不知道各位注意到了没有，难道我们的方法不对么
首先，加法和乘法运算，在没有括号等其他优先级的情况下是从左至右依次算的
我们来看一下
```r
> x<- c(1,2,3,4)  
> y<- c(1,2,3)  
> z<- c(2,3)  
> x+y  
[1] 2 4 6 5  
> x+y+z  
[1] 4 7 8 8  

```r
> z+y  
[1] 3 5 5  
> z+y+x  
[1] 4 7 8 7  
所以说，不同长度的向量相加，顺序也是很重要的
```